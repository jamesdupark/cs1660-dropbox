# cs1660-dropbox

## System Overview:

### General Symmetric Encryption/Verification:
Working with the dataserver requires the deterministic generation of Memlocs in a way that is unique to each user and not predictable. We will do this by taking advantage of the hashKDF function’s ability to deterministically generate keys given a purpose string. For a given Memloc, we will simply use the same base key with a given purpose (i.e. “priv_key_loc”) to generate a “key” (series of bytes) which we can then convert into a Memloc. This Memloc generation scheme will be used to generate Memlocs to store things unless explicitly stated otherwise.
Similarly, we will symmetrically encrypt and then sign using HMAC (encrypt then mac protocol) most of the individual pieces of data stored on the dataserver. We will do this using keys generated off a given base key and purpose (i.e. “priv_key_enc” and “priv_key_hmac”). Since these keys can be generated deterministically by an authenticated user/a user who knows the base key, we don’t need to store them, but instead can regenerate them when decrypting. Verification of file integrity can be done by comparing the stored HMAC code to the HMAC generated from the encrypted data.

### create_user():
When a user is created, we generate an asymmetric public & private key, a verify & signature key, and a dictionary for the User object’s shared_files field. We then initialize the User object, which contains a username (string), password (string), pub_key (asymmetric public key), priv_key (asymmetric private key), verify_key (public verification key), a sign_key (private signature key), and shared_files (a dictionary that tracks the owners of the files that have been shared with the user; filenames as keys, the owners’ usernames as values).
Then we check to see if the username is the empty string, or has already been taken. If so, we raise a DropboxError (to determine if the username has already been taken, we check a memloc of where a public key would be if a user with that username already exists. If we find a public key, the username has been taken). We then store the public keys in the keyserver, and serialize, symmetrically encrypt, generate memlocs, and store the private keys in the dataserver. We then return the User object, which holds all these values.

### authenticate_user():
When we want to authenticate a user, we first create a hollow User object holding just the username and password. We send it into a helper function authenticate(), which takes in a username and password. authenticate() retrieves all the public and private keys that should have been created, encrypted, and stored if create_user() was called on the username and password given to authenticate(). If authenticate() can retrieve and decrypt the public/private keys, we then confirm that each of the public/private keys can actually encrypt, decrypt, sign, and verify a given serialized plaintext. If the challenge succeeds, and the keys work, we pull the shared_files and shared_with fields’ data locations, decrypt them, and then assign the relevant keys/dictionaries to the relevant fields.

### upload_file():
We first set a generate_metadata flag to False, and then retrieve a file_key and the file’s metadata, if it already exists for the given filename for the User. If the file doesn’t already exist, we set the generate_metadata flag to True, create a new file_key, then encrypt and store it. We then slice the given data for the filename if necessary (if it’s > 16 bytes), and set block_count to one or two (two if we sliced the file). If generate_metadata is True, we then generate a new metadata dictionary for that file and set the “current” metadata flag to True. If the file already exists, and the flag “current” is False, then receive_file() again (to update your file_key and metadata), and call upload_file() again. If you’ve been revoked, the receive_file() will fail and raise a DropboxError. If the owner has revoked the file from a User that’s not the current User, then you update your file_key and upload_file() again.
We then take the block_count from the file metadata, and then encrypt/serialize/store the file metadata again. Afterwards, we create memlocs for the file data, and store/encrypt/sign/serialize the necessary file data (whether it be both the head and tail or just the head).

### download_file():
We first attempt to retrieve the file_key for the given filename. If no such file_key exists, we raise a DropboxError. We then attempt to retrieve the file metadata, and raise a DropboxError if the metadata is missing or has been corrupted. We then check the “current” flag in the file metadata, and call receive_file() if current == False, as the file_key has been updated (and then run download_file() again). 
If we have the file_key, it is current, and the file metadata is uncorrupted, we then, for range(0, block_count), retrieve and put each block together into one serialized string. We then print the string.

### append_file():
We first attempt to retrieve the file_key for the given filename. If no such file_key exists, we raise a DropboxError. We then attempt to retrieve the file metadata, and raise a DropboxError if the metadata is missing or has been corrupted. We then check the “current” flag in the file metadata, and call receive_file() if current == False, as the file_key has been updated (and then run append_file() again).
Given a file key, we access the block_count field of the metadata. Then, we retrieve the last block and append the new data to this last block. We slice the new last block if necessary (if it is larger than 16 bytes) and reupload the last block(s), incrementing the block count and re-storing file metadata as necessary. This design allows append_file() to meet its efficiency requirements because only the last block of a file (which is always at most 16 bytes long) and the file metadata (which is a constant size) are required to be downloaded, and the upload size only scales with the size of the data being appended.

### share_file():
In order to share a file, we first attempt to retrieve the file_key for the given file; if we can’t find the file_key, raise a DropboxError. We then retrieve the shared_w field from the metadata and store it on our User. We then find a common memloc that both the sender and the recipient can access through a key created via a string (unique to each file and sender/recipient combo). We then retrieve the recipient’s public key from the keyserver, and asymmetrically encrypt and sign the file_key for filename. If something already exists at the common memloc, we just use that dictionary; if not, create/serialize/encrypt a new dictionary and store it at that shared memloc. We then retrieve that shared dictionary at the shared memloc, add an entry with filename as the key and a list containing thethe asymmetrically encrypted file key and signature as the value. We re-encrypt the dictionary and store it at the shared memloc in the dataserver. We then update the shared_with field to include the new recipient. 

### recieve_file():
We attempt to retrieve the shared dictionary at the hypothetical common memloc, and if it exists, we decrypt it (if not, then the file was never shared by the sender— raise DropboxError). We then create the file_key_loc for that user for the new file they’re going to receive. We check if they already own a file with that filename, and if so, we raise an error. If it’s not a duplicate, we decrypt the file_key, verify it, and then encrypt it again with the recipient’s base_key, and set it at a new memloc that’s created with the recipient’s base_key. We push some changes to update the shared_file field, and then we push the shared_file change to the dataserver.
Now, the recipient is able to use the new file_key at their own base_key memloc.

### revoke_file():
In order to revoke a file, we need to update the master key for the file for everyone except the user that is being revoked, while signaling to users that they should update their file keys. We retrieve the old file data and metadata, editing the “current” field of the old metadata to be False, and pushing the updated metadata to the old location so that other users can access it. The pair share dictionary entry for the revoked user for the given filename is then updated with an empty list so that when the revoked user attempts to update their key, they can tell that the file has been revoked.
We then generate a new key to use as the master key for the new copy of the file and store it in the master key location, as well as generating new metadata to be associated with the given file. We then call upload_file with the old file contents, effectively uploading the file to a new location determined by the newly updated master key. Then, we access the list of users that the file is shared with from the owner’s shared_with dict, remove the revoked user from the list, and then call share_file on each user in this list (everyone except the revoked user) so that they will be able to access the new copy of the file. Users who still have access to the file will be able to update their file key when they next try to access the file, while the revoked user would not be able to access the file.


## Security Analysis
### Authentication:
The adversary (Eve) has observed that whenever Bob logs in, he always accesses two specific memlocs on the dataserver, and has figured out that this must be where his private keys are stored. She also notices that the private keys, unlike other keys, are not signed symmetrically. Eve then tries to overwrite the private keys with their own private key so that when Bob encrypts other files, he will encrypt them with the wrong key, allowing the adversary to read the file contents.
Our system prevents against this attack by verifying that the keys retrieved from the memlocs that they were stored in correspond directly to the public keys stored in the keyserver (which is immutable) - thus, even if the adversary did overwrite the keys, Bob’s authentication would simply fail because the retrieved keys would not be able to decrypt or sign a message in a way that corresponded to Bob’s registered public keys.

### Sharing:
The adversary (Eve) knows that when file access is revoked and the revoked user tries to access the file, they will be unable to update their key because in their pairwise sharing dictionary, an empty list is there in place of the usual encrypted key-signature pair. Eve knows that Bob has shared a file with Alice, but doesn’t want Alice to be able to access the file. Thus, Eve tries to forge a pairwise sharing dictionary with an empty list in place of the actual sharing key and replace the one that Bob has put there. That way, when Alice tries to receive the file, she will just see that the file has been revoked instead of being able to receive the key.
Our system prevents this attack by encrypting and signing the dictionary asymmetrically instead of symmetrically, as there is no way to share the symmetric key needed for encryption. Thus, Eve cannot decrypt and view the contents of the sharing dictionary, and even if Eve tries to overwrite the dictionary with her own forgery, it will not pass the integrity check.

### Storage:
The adversary, by watching traffic from the client to the Dataserver, manages to locate where a file’s metadata and blocks are stored. They know that file block storage increments, and that the file metadata holds a field called “block_count” that determines how many blocks to retrieve and print when calling download_file(). The adversary thus creates phony metadata setting block_count to an arbitrary number, and attempts to store some encrypted blocks in memlocs where download_file() might eventually reach if block_count was high enough.
Our system prevents this attack, as when it attempts to call download_file(), it realizes that the file metadata is corrupted as it fails to symmetrically decrypt and verify the metadata. This raises a DropboxError and alerts the user that the file metadata has been corrupted. 

### Sharing:
The adversary gains access to a file owner and the filename, and attempts to call receive_file() to gain access.
Our implementation prevents the adversary from gaining access to the file, despite knowing the filename and file owner, by creating a check that ensures there is a specifically created shared_dictionary between the owner and the intended recipient. Even if the attacker forges this dictionary, it is pointless, as that dictionary is where the file_key (that allows access to file contents) lives. If the adversary then manages to find the location of a shared_dictionary between two users to obtain the file_key, they are blocked from doing so, as the file_key is asymmetrically encrypted using the intended recipient’s public key, and so only the intended recipient can decrypt the shared_dictionary and access the file_key. 


### Known Vulnerabilities:
Our system’s design does not split metadata into read-only/read-write, so it is vulnerable to malicious actors editing the metadata in an unexpected way. Although most of these would be detected as an integrity violation, since anyone can edit the “current” field of the metadata, an attacker could set that field to “false” even though it was indeed the current version, preventing users from being able to access the file. To prevent this, we would have to sign the “current” field of the metadata asymmetrically instead of symmetrically so that only the owner could write to it in an integrity-preserving way.
Our system uses a “file_key” generated for each file to generate and store HMACs, so if an attacker can replace a file block with a symmetrically encrypted block using their own base_key, it is not caught by HMAC verification, as download_file() uses the file_key exclusively for verification (in other words, as long as there is one layer of symmetric encryption, it will always be valid). However, if an attacker does try to insert their own symmetrically encrypted block, it’s decryption will be unintelligible (random bytes).


